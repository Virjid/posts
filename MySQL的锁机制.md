---
title: MySQL的锁机制
date: 2019-06-30 19:30:42
tags:
    - MySQL
    - 数据库
---

## 并发控制

MySQL服务器可以并发处理多个连接，但有并发就势必会引入数据不一致的问题，比如当多个用户同时（即 并发地）购买商品（即 操作与商品信息相关的一张或多张表），很有可能出现超卖的现象。为此我们需要采取一些手段来保证一个用户的操作对其他的用户不造成影响，即保证数据的一致性，而这样的手段被称为并发控制。

如果没有做好并发控制，就会造成脏读、幻读和不可重复读。另外并发是为了提高处理请求的效率，如果并发控制**过于严格**，势必会极大地影响服务器的处理速度。

并发控制大致可以分为两类：

- 乐观锁
- 悲观锁



## 悲观锁 Pessimistic Concurrency Control

要严格保证当一个人正在修改数据时，另一个人不会访问（可能是读，也可能是写）该数据，最可靠、最直接的方法便是**不允许并发地访问该数据**。

一般数据库内部已经实现了相关的锁机制。借助该机制，对将要被修改的数据进行加锁，处于加锁状态的数据不可被其他人访问，仅当修改完成时才对该数据解锁。

> 这样的并发控制保守地认为**数据被修改时发生不一致的概率非常大**，因此被称为**悲观**锁。

悲观锁一般又分为两种：

- 共享锁
- 排它锁

### 共享锁

对行加锁，允许数据被并发地读，但有人读数据时不允许任何人对数据做修改

```sql
select ... LOCK IN SHARE MODE; # mysql语法
```



### 排他锁

对行加锁，不允许并发地读写，即同一时刻仅允许一个人对该数据进行读写。

一般数据库在使用INSERT/UPDATE/DELETE操作时，默认会对被操作的数据添加排他锁。

如果希望在查询时也对所检索的数据添加排他锁，可以使用如下语法：

```sql
select ... for update;
```



## 乐观锁 Optimistic Locking

相对于悲观锁，乐观锁在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。乐观并发控制会尽可能地将事务做下去，直到提交的时候才去锁定，因此不会产生任何锁，也不会出现死锁的情况。

乐观锁的实现并不需要借助于数据库的锁机制，它主要包含了两个步骤：

- 冲突检测
- 数据更新

其中一种实现方法是**基于版本控制**实现的。在数据库表中增加`version`列，类型为整数或时间戳。每当查询更新时，把之前查到的版本号和数据库版本号进行比对，如果当前版本号小于数据库版本号，则更新失败。